<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<!-- 1.说一下JS原生事件如何绑定 -->
JS原生绑定事件主要为三种：

1. html内联绑定

 其中：就是在html各种标签上直接添加事件，类似于css的行内样式，缺点是不好维护，因为散落在标签中,也就是耦合度太高

例如：<button onclick="事件处理函数"> 点我< /button>

2. 获取dom然后绑定，目前在PC端用的还是比较多的绑定事件方式，兼容性也好，主要是先获取dom元素，然后直接给dom元素添加事件 

 例如：var btn=document.getElementById(‘id元素’)

 btn.onclick=function() {

  ​     //要处理的事件逻辑

 }

 DOM0事件如何移除呢？很简单：btn.onclick=null;置为空就行

    优点：兼容性好
    
    缺点：只支持冒泡，不支持捕获

3. 使用addEventListener，移动端用的比较多，也有很多优点，

   1.提供了专门的绑定和移除方法

   2.控制冒泡和捕获

   3.可以同时绑定多个相同事件

  例如： var btn=document.getElementById(‘id元素’)

      //绑定事件
     btn.addEventListener(‘click’,绑定的事件处理函数名,false)
     //移除事件
     btn.removeEventListener(‘click’,要移除的事件处理函数名，false
     优点：支持给个元素绑定多个相同事件，支持冒泡和捕获事件机制


<!-- 2.说一下JS原生常用dom操作方法？ -->
js原生dom操作方法有

- 查找：

  - getElementByid,
  - getElementsByTagName,
  - getElementsByClassName,
  - querySelector,

- querySelectorAll

- 添加：

  - appendChild,insertBefore

- 删除：

  - removeChild
  - remove

- 克隆：

  - cloneNode

  - ```
    var spanNew =  document.querySelectorAll('span')[2].cloneNode(true); 
    document.body.appendChild(spanNew);
    ```

- 设置和获取属性：

  - setAttribute(“属性名”,”值”)  （原有属性设置，自定义属性设置）
  - getAttibute(“属性名”)
  - ele.属性名=属性值  （原有属性设置）
<!-- 3.说一下JS数组常用方法 -->
在开发中，数组使用频率很频繁，JS数组常用方法有

- push   尾部添加
- pop    尾部删除
- unshift  头部添加
- shift    头部删除
- splice   添加，删除，替换   (start,n,n1,n2)  start 从下标处开始  n 添加的个数 ， n1,n2  添加的元素
- join    将一个数组的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。
- concat  拼接数组元素
- forEach  遍历数组
- filter
- map  通过指定函数对数组进行处理,并将处理后的结果以新数组的形式返回 注意点:不会改变原数组,只是将处理后的结果以新数组的形式返回
- sort    排序
- some 一个符合
- every
- find  第一个符合条件的元素
- findeIndex
<!-- 4.说一下JS数组常用方法 -->

<!-- 5.JavaScript的基本类型和复杂类型是储存在哪里的 -->
基本类型储存在栈中，但是一旦被闭包引用则成为常住内存，会储存在内存堆中。

复杂类型会储存在内存堆中。

堆和栈的区别
1、栈：存储 基本数据类型 或者地址           堆：存多个值的复合类型

2、栈：存储空间小                          堆：存储空间大

3、栈：查找迅速性能高						堆：查找相对慢


<!-- 6.简述同步与异步的区别 -->
- 同步：
  - 浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作
  - 代码从上往下依次执行，执行完当前代码，才能执行下面的代码。（阻塞）

- 异步：
/

  - 浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容

  - 代码从上往下依次执行，没执行完当前代码，也能执行下面的代码。（非阻塞
<!--7. JavaScript垃圾回收原理 -->
- 在javascript中，如果一个变量不再被引用，那么这个对象就会被GC回收；

- 如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收
<!--8. 请描述值类型(基本数据类型)和引用类型的区别 -->
- 值类型

- - 占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，
在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了
。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，
`基础变量的值是存储在栈中`，而引用变量存储在栈中的是`指向堆中的数组或者对象的地址`，
这就是为何修改引用类型总会影响到其他指向这个地址的引用变量）

- - 保存与复制的是值本身

- - 使用typeof检测数据的类型

- - 基本类型数据是值类型

- 引用类型

- - 占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，
以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁
，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象`依然不会被销毁`，
只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）

- - 保存与复制的是指向对象的一个指针

- - 使用instanceof检测数据类型


- - 使用new()方法构造出的对象是引用型
<!--9. 浏览器是如何渲染页面的 -->
渲染的流程如下：



1.解析HTML文件，创建DOM树。

自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。

2.解析CSS。优先级：浏览器默认设置<用户设置<外部样式<内联样式<HTML中的style样式；

 3.将CSS与DOM合并，构建渲染树（Render Tree） -->

<!-- 4.布局和绘制，重绘（repaint）和重排（reflow） -->
<!--10. 数组去重复 三种方式实现 -->
<!-- ## 十、WEB页面性能优化面试题 -->

1、HTML结构要清晰，尽可能使用语义化标签

2、减少外部HTTP请求

3、 压缩 CSS, JS 和 HTML

4、使用 CDN 和缓存提高速度

5、尽量使用使用轻量级框架

6、使用异步加载，延迟加载依赖

7、尽可能使用CSS3动画，相比JavaScript驱动的动画效率更高

8、使用事件委托，防止绑定不必要的大量事件

9、公用的css和js尽量写成公共样式/函数来条调用

10、控制DOM大小，清除多余的DOM节点

11、链接CSS，避免使用@import,避免CSS表达式

12、CSS Sprites雪碧图、icon图标，base64图片

13、尽量合并样式表和js 减少请求次数

14、Html标签、css类名、js变量命名尽量规范 见名知意。

15、将样式表放在头部,脚本放在底部
  

#### 8.  说一下你对JS面向(使用)对象的理解

JS面向对象主要基于function 构造函数来实现的 通过function来模拟类 通过prototype来实现类方法的共享，
自从有了ES6后，通过class来定义类，通过extends来继承父类，其实ES6类的实现本质上是一个语法糖，不过对于开发简单了好多。

[{name:'',price,protise:[]}]
面向对象是一种编程思维，分为面向过程和面向对象
面相过程的思维方式，它更加注重这个事情的每一个步骤以及顺序。他比较直接高效，需要做什么可以直接开始干。

面向对象的思维方式，它更加注重事情有哪些参与者，需求里面有哪些对象，这些对象各自需要做些什么事情。将其拆解成一个个模块和对象，这样会更易于维护和拓展。
面向对象的三大特征：封装，继承 多态






#### 11. 说一下JS作用域

     JS作用域也就是JS识别变量的范围,作用域链也就是JS查找变量的顺序

    -  先说作用域,JS作用域主要包括全局作用域、局部作用域和ES6的块级作用域
    - 全局作用域,也就是定义在window下的变量范围.在任何地方都可以访问，
    - 局部作用域：是只在函数内部定义的变量范围
    - es6块级作用域.简单来说用let和const在任意的代码块中定义的变量都认为是块级作用域中的变量，例如在for循环中用let定义的变量，
    在if语句中用let定义的变量等等

注: 1. 尽量不要使用全局变量. 因为容易导致全局的污染  命名冲突  对bug查找不利。

    2. 而所谓的作用域链就是由最内部的作用域往最外部,查找变量的过程.形成的链条就是作用域链

 #### 13.  说一下JS事件代理（也称事件委托）是什么，及实现原理？

    JS事件代理就是通过给父级元素（例如：ul）绑定事件，不给子级元素(例如：li)绑定事件，然后当点击子级元素时，
    通过事件冒泡机制在其绑定的父元素上触发事件处理函数，主要目的是为了提升性能，因为我不用给每个子级元素绑定事件，
    只给父级元素绑定一次就好了,在原生js里面是通过event对象的targe属性实现

 #### 17. null与undefined的区别是什么？

    null表示为空，代表此处不应该有值的存在，一个对象可以是null，代表是个空对象，而null本身也是对象。
    
    undefined表示『不存在』，JavaScript是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），
    这就是undefined的意义所在



#### 34. 请你谈谈cookie的弊端？

    语法：document.cookie="name=username; expires=" + dtae.toGMTString();
   
   1、作用 往返于服务器和客户端，传递信息。 服务器会给客户端存cookie，我们发起ajax请求的时候也可以携带cookie
   
   2、用于数据缓存，页面通信 现在已经被 h5本地存储 storage代替
   
   3、七天免登录
   
   弊端
   1.Cookie 数量和长度的限制。每个 domain 最多只能有 20 条 cookie，每个 cookie 长度 不能超过 4KB，否则会被截掉。
   2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，
   他只要原样转发cookie就可以达到目的了。

    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，
    那么它起不到任何作用。




#### 37. JavaScript 中的强制转型是指什么？

在 JavaScript 中数据类型有两种转换形式：显式和隐式。
显示转换：当系统默认转换不能转换的时候，而我们又需要把某一类型改为另一个类型，这一过程叫显示转换
隐式转换：系统默认的，不需要加以声明就可以进行转换的


41.  匿名和命名函数有什么区别？
匿名函数通常是某一个事件触发后 进行触发的，没有名字的函数，在声明函数时不写函数名称，（将函数赋值给变量）叫匿名函数，
匿名函数不能够提前调用，会报错，需要在函数声明之后调用
命名函数可以进行预先的封装，在需要使用的地方通过调用函数名运行


#### 42.   什么是 JavaScript 中的提升操作？

提升（hoisting）是 JavaScript 解释器将所有变量和函数声明移动到当前作用域顶部的操作。有两种类型的提升：

- 变量提升——非常少见
- 函数提升——常见

无论 var（或函数声明）出现在作用域的什么地方，它都属于整个作用域，并且可以在该作用域内的任何地方访问它。

#### 43.  js严格模式

1. 开启严格模式   'use strict';     函数内部 

2. 必须使用 var let 声明变量

3. 不能 delete 删除 变量

4. 全局作用域函数中 this值是undefined

</body>
</html>